/**
 * Module dependencies.
 */var start=require("./common"),mongoose=start.mongoose,Schema=mongoose.Schema,utils=require("../lib/utils"),StateMachine=require("../lib/statemachine"),ObjectId=require("../lib/types/objectid"),MongooseBuffer=require("../lib/types/buffer"),assert=require("assert"),ActiveRoster=StateMachine.ctor("require","init","modify");describe("utils",function(){it("should detect a path as required if it has been required",function(){var e=new ActiveRoster;e.require("hello");assert.equal(e.paths.hello,"require")});it("should detect a path as inited if it has been inited",function(){var e=new ActiveRoster;e.init("hello");assert.equal(e.paths.hello,"init")});it("should detect a path as modified",function(){var e=new ActiveRoster;e.modify("hello");assert.equal(e.paths.hello,"modify")});it("should remove a path from an old state upon a state change",function(){var e=new ActiveRoster;e.init("hello");e.modify("hello");assert.ok(!e.states.init.hasOwnProperty("hello"));assert.ok(e.states.modify.hasOwnProperty("hello"))});it("forEach should be able to iterate through the paths belonging to one state",function(){var e=new ActiveRoster;e.init("hello");e.init("goodbye");e.modify("world");e.require("foo");e.forEach("init",function(e){assert.ok(~["hello","goodbye"].indexOf(e))})});it("forEach should be able to iterate through the paths in the union of two or more states",function(){var e=new ActiveRoster;e.init("hello");e.init("goodbye");e.modify("world");e.require("foo");e.forEach("modify","require",function(e){assert.ok(~["world","foo"].indexOf(e))})});it("forEach should iterate through all paths that have any state if given no state arguments",function(){var e=new ActiveRoster;e.init("hello");e.init("goodbye");e.modify("world");e.require("foo");e.forEach(function(e){assert.ok(~["hello","goodbye","world","foo"].indexOf(e))})});it("should be able to detect if at least one path exists in a set of states",function(){var e=new ActiveRoster;e.init("hello");e.modify("world");assert.ok(e.some("init"));assert.ok(e.some("modify"));assert.ok(!e.some("require"));assert.ok(e.some("init","modify"));assert.ok(e.some("init","require"));assert.ok(e.some("modify","require"))});it("should be able to `map` over the set of paths in a given state",function(){var e=new ActiveRoster;e.init("hello");e.modify("world");e.require("iAmTheWalrus");var t=e.map("init","modify",function(e){return e+"-suffix"});assert.deepEqual(t,["hello-suffix","world-suffix"])});it("should `map` over all states' paths if no states are specified in a `map` invocation",function(){var e=new ActiveRoster;e.init("hello");e.modify("world");e.require("iAmTheWalrus");var t=e.map(function(e){return e+"-suffix"});assert.deepEqual(t,["iAmTheWalrus-suffix","hello-suffix","world-suffix"])});it("test utils.options",function(){var e={a:1,b:2,c:3,0:"zero1"},t={b:10,d:20,0:"zero2"},n=utils.options(t,e);assert.equal(1,n.a);assert.equal(n.b,2);assert.equal(n.c,3);assert.equal(n.d,20);assert.deepEqual(e.d,n.d);assert.equal(n[0],"zero1");var r=utils.options(t);assert.equal(r.b,10);assert.equal(r.d,20);assert.equal(r[0],"zero2");assert.deepEqual(t,r);assert.notEqual(t,r)});it("test deepEquals on ObjectIds",function(){var e=(new ObjectId).toString(),t=new ObjectId(e),n=new ObjectId(e);assert.ok(utils.deepEqual(t,n));assert.ok(utils.deepEqual(t,t));assert.ok(!utils.deepEqual(t,new ObjectId))});it("deepEquals on MongooseDocumentArray works",function(){var e=start(),t=new Schema({a:String}),n=e.model("deepEqualsOnMongooseDocArray",new Schema({a1:[t],a2:[t]}));e.close();var r=new n({a1:[{a:"Hi"},{a:"Bye"}]});r.a2=r.a1;assert.ok(utils.deepEqual(r.a1,r.a2));var i=new n;i.init(r.toObject());assert.ok(utils.deepEqual(r.a1,i.a1));i.set(r.toObject());assert.ok(utils.deepEqual(r.a1,i.a1))});it("deepEquals with MongooseBuffer",function(){var e="this is the day",t=new MongooseBuffer(e),n=new MongooseBuffer(e),r=new Buffer(e),i=new Buffer("this is the way"),s=new Buffer("other length");assert.ok(utils.deepEqual(t,n));assert.ok(utils.deepEqual(t,r));assert.ok(!utils.deepEqual(t,i));assert.ok(!utils.deepEqual(t,s));assert.ok(!utils.deepEqual(t,[]));assert.ok(!utils.deepEqual([],t))})});