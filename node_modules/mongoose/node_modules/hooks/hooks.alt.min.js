/**
 * Hooks are useful if we want to add a method that automatically has `pre` and `post` hooks.
 * For example, it would be convenient to have `pre` and `post` hooks for `save`.
 * _.extend(Model, mixins.hooks);
 * Model.hook('save', function () {
 *  console.log('saving');
 * });
 * Model.pre('save', function (next, done) {
 *  console.log('about to save');
 *  next();
 * });
 * Model.post('save', function (next, done) {
 *  console.log('saved');
 *  next();
 * });
 *
 * var m = new Model();
 * m.save();
 * // about to save
 * // saving
 * // saved 
 */// TODO Add in pre and post skipping options
module.exports={hook:function(e,t,n){function u(){}if(arguments.length===1&&typeof e=="object"){for(var r in e)this.hook(r,e[r]);return}n||(n=t);var i=this.prototype||this,s=i._pres=i._pres||{},o=i._posts=i._posts||{};s[e]=s[e]||[];o[e]=o[e]||[];i[e]=function(){function l(){arguments[0]instanceof Error&&n(arguments[0])}function c(){if(arguments[0]instanceof Error)return n(arguments[0]);arguments.length&&(a=[].slice.call(arguments));t.apply(r,a);var e=s.map(function(t,i){var s=function(){if(arguments[0]instanceof Error)return n(arguments[0]);arguments.length&&(a=[].slice.call(arguments));t.apply(r,[e[i+1]||u].concat(a))};return s});e.length&&e[0]()}var r=this,i=this._pres[e],s=this._posts[e],o=0,a=[].slice.call(arguments),f=i.map(function(e,t){var i=function(){if(arguments[0]instanceof Error)return n(arguments[0]);if(o){arguments.length&&(a=[].slice.call(arguments,2));e.apply(r,[f[t+1]||l,h].concat(a))}else{arguments.length&&(a=[].slice.call(arguments));e.apply(r,[f[t+1]||c].concat(a))}};(i.isAsync=e.isAsync)&&o++;return i});if(o){complete=o;function h(){if(arguments[0]instanceof Error)return n(arguments[0]);--complete||c.call(this)}}(f[0]||c)()};return this},pre:function(e,t,n){var r=this.prototype,i=r._pres=r._pres||{};(t.isAsync=n)&&this.prototype[e].numAsyncPres++;(i[e]=i[e]||[]).push(t);return this},post:function(e,t,n){var r=this.prototype,i=r._posts=r._posts||{};(i[e]=i[e]||[]).push(t);return this}};